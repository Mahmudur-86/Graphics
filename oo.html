#include <GL/glut.h>
#include <vector>
#include <cmath>
#include <string>

struct Mosquito {
    float x, y, z;
    float angle;
    float wingAngle;
    float speed;
    float size;
    bool breeding;
};

struct WaterPool {
    float x, y;
    float radius;
    float ripplePhase;
    bool active;
    std::vector<float> ripples;
};

std::vector<Mosquito> mosquitos;
std::vector<WaterPool> pools;
float time = 0;

void drawRipple(float x, float y, float radius, float phase) {
    glPushMatrix();
    glTranslatef(x, y, 0);
    glColor4f(0.0f, 0.6f, 1.0f, 0.3f);

    for(int i = 0; i < 3; i++) {
        float rippleRadius = radius * (1.0f + 0.2f * sin(phase + i * 2.0f));
        glBegin(GL_LINE_LOOP);
        for(int j = 0; j < 50; j++) {
            float angle = 2.0f * M_PI * j / 50;
            glVertex2f(rippleRadius * cos(angle), rippleRadius * sin(angle));
        }
        glEnd();
    }
    glPopMatrix();
}

void drawMosquito(const Mosquito& m) {
    glPushMatrix();
    glTranslatef(m.x, m.y, m.z);
    glRotatef(m.angle, 0, 0, 1);

    // Body
    if(m.breeding)
        glColor3f(1.0f, 0.2f, 0.2f);
    else
        glColor3f(0.2f, 0.2f, 0.2f);

    glBegin(GL_TRIANGLE_FAN);
    for(int i = 0; i < 360; i += 20) {
        float rad = i * M_PI / 180.0f;
        glVertex2f(m.size * cos(rad), m.size * 0.5f * sin(rad));
    }
    glEnd();

    // Wings with animation
    glColor4f(0.8f, 0.8f, 0.8f, 0.6f);
    float wingY = sin(m.wingAngle) * 0.03f;

    glBegin(GL_TRIANGLES);
    // Left wing
    glVertex2f(-0.02f, 0);
    glVertex2f(-0.05f, wingY);
    glVertex2f(-0.05f, -wingY);

    // Right wing
    glVertex2f(0.02f, 0);
    glVertex2f(0.05f, wingY);
    glVertex2f(0.05f, -wingY);
    glEnd();

    glPopMatrix();
}

void drawWaterPool(const WaterPool& p) {
    if(!p.active) return;

    // Main pool
    glColor4f(0.0f, 0.4f, 0.8f, 0.7f);
    glBegin(GL_TRIANGLE_FAN);
    for(int i = 0; i < 360; i += 10) {
        float angle = i * M_PI / 180.0f;
        glVertex2f(p.x + p.radius * cos(angle), p.y + p.radius * sin(angle));
    }
    glEnd();

    // Animated ripples
    drawRipple(p.x, p.y, p.radius, p.ripplePhase);
}

void update(int) {
    time += 0.016f;

    // Update mosquitos
    for(auto& m : mosquitos) {
        m.wingAngle += 0.5f;
        m.angle += sin(time) * 2.0f;
        m.x += cos(m.angle * M_PI / 180.0f) * m.speed;
        m.y += sin(m.angle * M_PI / 180.0f) * m.speed;

        if(m.x < -1.0f || m.x > 1.0f) m.angle = 180.0f - m.angle;
        if(m.y < -1.0f || m.y > 1.0f) m.angle = -m.angle;

        // Breeding near water
        m.breeding = false;
        for(const auto& p : pools) {
            if(p.active) {
                float dx = m.x - p.x;
                float dy = m.y - p.y;
                if(sqrt(dx*dx + dy*dy) < p.radius * 1.5f) {
                    m.breeding = true;
                    if(rand() % 100 < 1 && mosquitos.size() < 50) {
                        mosquitos.push_back({m.x, m.y, 0,
                            float(rand() % 360),
                            0, 0.003f, 0.02f, false});
                    }
                }
            }
        }
    }

    // Update water effects
    for(auto& p : pools) {
        if(p.active) p.ripplePhase += 0.05f;
    }

    glutPostRedisplay();
    glutTimerFunc(16, update, 0);
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Draw all elements
    for(const auto& p : pools) drawWaterPool(p);
    for(const auto& m : mosquitos) drawMosquito(m);

    // Display count
    glColor3f(0.0f, 0.0f, 0.0f);
    glRasterPos2f(-0.95f, 0.9f);
    std::string text = "Mosquitos: " + std::to_string(mosquitos.size());
    for(char c : text) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);

    glutSwapBuffers();
}

void mouse(int button, int state, int x, int y) {
    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        float nx = (2.0f * x) / glutGet(GLUT_WINDOW_WIDTH) - 1.0f;
        float ny = 1.0f - (2.0f * y) / glutGet(GLUT_WINDOW_HEIGHT);

        for(auto& p : pools) {
            if(!p.active) continue;
            float dx = nx - p.x;
            float dy = ny - p.y;
            if(sqrt(dx*dx + dy*dy) < p.radius) {
                p.active = false;
                break;
            }
        }
    }
}

void init() {
    glClearColor(0.95f, 0.95f, 0.95f, 1.0f);

    // Initialize pools
    for(int i = 0; i < 5; i++) {
        pools.push_back({
            (float)(rand() % 200 - 100) / 100.0f,
            (float)(rand() % 200 - 100) / 100.0f,
            0.15f, 0, true, {}
        });
    }

    // Initial mosquitos
    for(int i = 0; i < 5; i++) {
        mosquitos.push_back({
            (float)(rand() % 200 - 100) / 100.0f,
            (float)(rand() % 200 - 100) / 100.0f,
            0,
            (float)(rand() % 360),
            0, 0.003f, 0.02f, false
        });
    }
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);
    glutInitWindowSize(800, 600);
    glutCreateWindow("Enhanced Dengue Awareness");

    init();
    glutDisplayFunc(display);
    glutMouseFunc(mouse);
    glutTimerFunc(0, update, 0);
    glutMainLoop();
    return 0;
}
